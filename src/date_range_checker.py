""" GDELT Date Range Checker Utility to check the actual date ranges available in GDELT BigQuery and free methods. """ import sys import os from pathlib import Path # Add project root to path project_root = Path(__file__).parent.parent sys.path.insert(0, str(project_root)) import pandas as pd from datetime import datetime, timedelta import logging # Now import from src from src.config import load_env_file logger = logging.getLogger(__name__) def check_bigquery_date_range(): """Check the earliest and latest dates available in GDELT BigQuery.""" print("[BIGQUERY CHECK] Checking GDELT BigQuery Date Range") print("=" * 50) try: from google.cloud import bigquery from src.config import config # Load environment load_env_file() project_id = config.google_project_id credentials_path = config.google_credentials_path if not project_id: print("[ERROR] No Google Cloud project ID configured") return None # Create BigQuery client client = bigquery.Client(project=project_id) # Query to find date range in GDELT events table query = """ SELECT MIN(SQLDATE) as earliest_date, MAX(SQLDATE) as latest_date, COUNT(*) as total_events FROM `gdelt-bq.gdeltv2.events` LIMIT 1 """ print("Querying GDELT BigQuery for date range...") # Use dry run to estimate cost first job_config = bigquery.QueryJobConfig(dry_run=True, use_query_cache=False) dry_run_job = client.query(query, job_config=job_config) cost_estimate = dry_run_job.total_bytes_processed / (1024**4) * 5 # Approximate cost print(f"[COST] Estimated cost: ${cost_estimate:.4f}") # Run actual query job_config = bigquery.QueryJobConfig(dry_run=False) query_job = client.query(query, job_config=job_config) results = query_job.result() for row in results: earliest = str(row.earliest_date) latest = str(row.latest_date) total = row.total_events # Convert GDELT date format (YYYYMMDD) to readable format earliest_date = f"{earliest[:4]}-{earliest[4:6]}-{earliest[6:8]}" latest_date = f"{latest[:4]}-{latest[4:6]}-{latest[6:8]}" print(f"[OK] BigQuery GDELT Events Table:") print(f" [DATE] Earliest date: {earliest_date}") print(f" [DATE] Latest date: {latest_date}") print(f" [COUNT] Total events: {total:,}") return { 'method': 'bigquery', 'earliest_date': earliest_date, 'latest_date': latest_date, 'total_events': total, 'status': 'available' } except Exception as e: print(f"[ERROR] BigQuery check failed: {e}") return { 'method': 'bigquery', 'status': 'unavailable', 'error': str(e) } def check_free_method_date_range(): """Check the date range limitations for the free GDELT method.""" print("\n[FREE CHECK] Checking Free Method Date Range") print("=" * 50) try: from gdelt import gdelt # The free GDELT API typically covers: # - GDELT 1.0: April 1, 1979 to March 31, 2013 # - GDELT 2.0: February 19, 2015 onwards print("[LIMITS] Free Method (GDELT API) Limitations:") print(" [RANGE] GDELT 1.0: 1979-04-01 to 2013-03-31") print(" [RANGE] GDELT 2.0: 2015-02-19 to present") print(" [GAP] Gap: 2013-04-01 to 2015-02-18 (no data)") print(" Speed: Limited to ~100-1000 events per request") print(" [COST] Cost: Free") # Test a small query to verify API is working print("\n[TEST] Testing free API connection...") client = gdelt.gdelt() # Test with a very recent small date range test_date = (datetime.now() - timedelta(days=7)).strftime("%Y-%m-%d") test_df = client.Search([test_date, test_date], table="events", normcols=True) if len(test_df) > 0: print(f"[SUCCESS] Free API working - test query returned {len(test_df)} events") else: print("[WARNING] Free API returned no events for test query") return { 'method': 'free', 'earliest_date': '1979-04-01', # GDELT 1.0 start 'latest_date': datetime.now().strftime("%Y-%m-%d"), # Today 'gaps': ['2013-04-01 to 2015-02-18'], 'limitations': 'Limited events per request, slower', 'status': 'available' } except Exception as e: print(f"[ERROR] Free method check failed: {e}") return { 'method': 'free', 'status': 'unavailable', 'error': str(e) } def recommend_date_ranges(): """Provide recommendations for optimal date ranges.""" print("\n[INFO] Recommended Date Ranges") print("=" * 50) current_date = datetime.now().strftime("%Y-%m-%d") print("[TARGET] For Macro Sentiment Trading:") print(f" [TREND] Recent data: 2020-01-01 to {current_date}") print(f" [CHART] Medium-term: 2015-02-19 to {current_date}") print(f" Long-term: 2015-02-19 to {current_date} (BigQuery recommended)") print("\n Performance Recommendations:") print(" BigQuery: Use for any date range (fast, comprehensive)") print(" Free method: Use for small date ranges only (< 1 month)") print(" For backtesting: Start with 2015-02-19 (GDELT 2.0 launch)") print("\n[MONEY] Cost Considerations:") print(" BigQuery: ~$0.002 per day of data") print(" 10 years (2015-2025): ~$7-8 total") print(" Free method: $0 but very slow for large ranges") def check_all_date_ranges(): """Check date ranges for all available methods.""" print("[SEARCH] GDELT Data Range Analysis") print("=" * 60) results = {} # Check BigQuery bq_result = check_bigquery_date_range() if bq_result: results['bigquery'] = bq_result # Check free method free_result = check_free_method_date_range() if free_result: results['free'] = free_result # Show recommendations recommend_date_ranges() return results if __name__ == "__main__": # Run comprehensive check results = check_all_date_ranges() print("\n[LIST] Summary") print("=" * 30) for method, result in results.items(): if result['status'] == 'available': print(f"{method}: {result['earliest_date']} to {result['latest_date']}") else: print(f"{method}: [ERROR] {result.get('error', 'Unknown error')}") 